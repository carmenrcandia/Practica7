<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Modelo OBJ Interactivo WebGL2</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            display: block;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        body {
            display: flex;
            /* Para que sidebar y canvas estén lado a lado */
        }

        .sidebar {
            width: 200px;
            background: #222;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar button {
            padding: 10px;
            background: #555;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 5px;
        }

        .sidebar button:hover {
            background: #888;
        }
    </style>
    <script src="webgl-obj-loader.js"></script>
</head>

<body>
    <div class="sidebar">
        <div id="infoModelo" style="color:white; font-size:14px;">Modelo seleccionado: ninguno</div>
        <h3 style="color:white; font-size:14px;">Controles</h3>
        <button id="reset" class="button">Reiniciar</button>

        <button id="zoomMas">Zoom +</button>
        <button id="zoomMenos">Zoom -</button>
        <button id="malla">Malla</button>
        <button id="mover">Mover</button>
        <!-- Combo box -->
        <label for="seleccionModelo" style="color:white;">Cambiar el Color del objeto:</label>
        <select id="seleccionModelo">
            <option value="craneo">Cráneo</option>
            <option value="tronco">Tronco</option>
            <option value="omoplato">Omóplato</option>
            <option value="pelvis">Pelvis</option>
            <option value="extremidadesI">Extremidades Inferiores</option>
            <option value="extremidadesSup">Extremidades Inferiores</option>
            <option value="clavicula">Clavicula </option>
            <option value="corazon">Corazon </option>
        </select>
    </div>

    <canvas id="webglcanvas" style="border: none;" width="500" height="500"></canvas>
    <script id="vs" type="vertex">
        #version 300 es
        precision mediump float;
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec3 aVertices;
        layout(location = 1) in vec2 aCoordenadasDeTextura;
        out vec2 vCoordenadasDeTextura;
        void main() {
            vCoordenadasDeTextura = aCoordenadasDeTextura;  
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
        }
      </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D uUnidadDeTextura;
        in vec2 vCoordenadasDeTextura;
        out vec4 color;
        void main() {
            color = texture(uUnidadDeTextura, vCoordenadasDeTextura); 
        }
      </script>

    <script>
        "use strict";


        /* Convierte de grados a radianes */
        function toRadians(grados) {
            return grados * Math.PI / 180;
        };

        /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
            let r = new Array(16);
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = tx;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = ty;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Escalación - glScalef */
        function escalacion(matriz, sx, sy, sz) {
            let r = new Array(16);
            r[0] = sx; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = sy; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Rotación sobre X - glRotatef */
        function rotacionX(matriz, theta) {
            let r = new Array(16);
            let c = Math.cos(toRadians(theta));
            let s = Math.sin(toRadians(theta));
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = c; r[9] = -s; r[13] = 0;
            r[2] = 0; r[6] = s; r[10] = c; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Rotación sobre Y - glRotatef */
        function rotacionY(matriz, theta) {
            let r = new Array(16);
            let c = Math.cos(toRadians(theta));
            let s = Math.sin(toRadians(theta));
            r[0] = c; r[4] = 0; r[8] = s; r[12] = 0;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
            r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Rotación sobre Z - glRotatef */
        function rotacionZ(matriz, theta) {
            let r = new Array(16);
            let c = Math.cos(toRadians(theta));
            let s = Math.sin(toRadians(theta));
            r[0] = c; r[4] = -s; r[8] = 0; r[12] = 0;
            r[1] = s; r[5] = c; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2 / (der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq) / (der - izq);
            r[1] = 0; r[5] = 2 / (arr - abj); r[9] = 0; r[13] = -(arr + abj) / (arr - abj);
            r[2] = 0; r[6] = 0; r[10] = -2 / (lejos - cerca); r[14] = -(lejos + cerca) / (lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Proyección Perspectiva - glFrustum */
        function frustum(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2 * cerca / (der - izq); r[4] = 0; r[8] = (der + izq) / (der - izq); r[12] = 0;
            r[1] = 0; r[5] = 2 * cerca / (arr - abj); r[9] = (arr + abj) / (arr - abj); r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] = -2 * lejos * cerca / (lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = -1; r[15] = 0;
        }

        /* Proyección Perspectiva - gluPerspective */
        function perspective(r, fovy, aspecto, cerca, lejos) {
            let ang = fovy * 0.5;
            let f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
            r[0] = f / aspecto; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = f; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] = -2.0 * lejos * cerca / (lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = - 1.0; r[15] = 0;
        }

        /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
            let r = new Array(16);
            let i, j, k;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    let s = 0;
                    for (k = 0; k < 4; k++)
                        s = s + a[i + k * 4] * b[k + j * 4];
                    r[i + j * 4] = s;
                }
            }
            for (i = 0; i < 16; i++)
                c[i] = r[i];
        }



        // ----------------- Variables globales -----------------
        let canvas, gl, programaID, modeloVAO, modelo;
        let anguloX = 0, anguloY = 0, anguloZ = 0;
        let rotX = false, rotY = false, rotZ = false;
        let rotAutoX = false, rotAutoY = false, rotAutoZ = false;
        let antX, antY, boton_izq_presionado = false;
        let movimientoAutomatico = true;
        let rotManualX = 0, rotManualY = 0;
        let uMatrizProyeccion;
        let uMatrizVista;
        let uMatrizModelo;
        let uUnidadDeTextura;

        let zoom = 5;


        /* Matrices */
        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);

        let MatrizRotacion = new Array(16);
        let B = new Array(16);
        let arcBall;

        let modelos = [];
        let modeloActivo = 0;
        let modoMalla = true;
        let modoMover = false;

        let arrastrando = false;
        let offsetX = 0, offsetY = 0;


        class Vector3 {

            /**
             * Construye un nuevo Vector.
             */
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            mas(v2) {
                return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z));
            }

            menos(v2) {
                return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z));
            }

            producto_vectorial(v2) {
                let r = new Vector3();
                r.x = (this.y * v2.z) - (this.z * v2.y);
                r.y = (this.z * v2.x) - (this.x * v2.z);
                r.z = (this.x * v2.y) - (this.y * v2.x);
                return r;
            }

            producto_escalar(v2) {
                return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z);
            }

            longitud() {
                return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
            }


            normaliza() {
                let l = this.longitud();
                if (l > 0) {
                    this.x = this.x / l;
                    this.y = this.y / l;
                    this.z = this.z / l;
                }
            }
            normal(v1, v2, v3) {
                let u = new Vector3(); // vector u
                let v = new Vector3(); // vector v
                let n = new Vector3(); // vector n

                /* Calcula los vectores u y v */
                u = v2.menos(v1);
                v = v3.menos(v1);

                /* n = u x v */
                n = u.producto_vectorial(v);

                /* Normaliza */
                n.normaliza();

                return n;
            }

            toString() {
                return "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
            }
        }


        let Punto2f = function (x, y) {
            // Atributos publicos
            this.x = x;
            this.y = y;
        }

        class ArcBall {

            /**
             * Construye un nuevo ArcBall.
             */
            constructor(w, h) {
                this.Epsilon = 1.0e-5;
                this.U = new Vector3();
                this.V = new Vector3();
                this.ajusta(w, h);
            }

            /* Ajusta el ancho y alto de la ventana */
            ajusta(w, h) {
                if (!((w > 1.0) && (h > 1.0)))
                    document.write("ERROR");

                /* Ajusta el factor para el ancho y alto (2 = [-1..1]) */
                this.ajustaAncho = 2.0 / (w - 1.0);
                this.ajustaAlto = 2.0 / (h - 1.0);
            }

            /* Obtiene el vector dado un punto (x,y) */
            obtieneVector(vector, x, y) {
                /* Copia punto */
                let temp = new Punto2f(x, y);

                /* Ajusta las coordenadas del punto al rango [-1..1] */
                temp.x = (temp.x * this.ajustaAncho) - 1.0;
                temp.y = 1.0 - (temp.y * this.ajustaAlto);

                /* Calcula el cuadrado de la longitud del vector */
                let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);


                if (longitud2 > 1.0) {
                    /* Calcula un factor de normalización (radio / sqrt(longitud2)) */
                    let norma = (1.0 / Math.sqrt(longitud2));

                    /* Retorna el vector "normalizado", un punto sobre la esfera */
                    vector.x = temp.x * norma;
                    vector.y = temp.y * norma;
                    vector.z = 0.0;
                } else { /* e.o.c. está dentro */
                    /*
                     * Retorna un vector, un punto dentro la esfera 
                     * z = sqrt(radio^cuadrado - (x^2 + y^2))
                     */
                    vector.x = temp.x;
                    vector.y = temp.y;
                    vector.z = Math.sqrt(1.0 - longitud2);
                }
            }

            /* Obtiene el vector U */
            primerPunto(x, y) {
                this.obtieneVector(this.U, x, y);
            }

            /* Obtiene el Cuaternion de U y V */
            segundoPunto(x, y) {

                let q = new Cuaternion();

                /* Obtiene el vector V */
                this.obtieneVector(this.V, x, y);

                /* Retorna el cuaternión equivalente a la rotación. */
                if (q != null) {

                    /* Calcula la Normal = U x V */
                    let Normal = this.U.producto_vectorial(this.V);

                    /* Calcula la longitud de la normal */
                    if (Normal.longitud() > this.Epsilon) { /* si no es cero */
                        q.x = Normal.x;
                        q.y = Normal.y;
                        q.z = Normal.z;
                        /* w  = (theta / 2), donde theta es el ángulo de rotación */
                        q.w = this.U.producto_escalar(this.V);
                    } else { /* si es cero */
                        /* U y V coinciden */
                        q.x = q.y = q.z = q.w = 0.0;
                    }
                }
                return q;
            }
        }


        class Cuaternion {

            /**
             * Construye un nuevo Cuaternion.
             */
            constructor(w, x, y, z) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
            }

            inicializa(w, v) {
                this.w = w;
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
            }

            // norma^2 = w^2 + x^2 + y^2 + z^2
            norma2() {
                return (this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            }

            // Conjugado
            conjugado() {
                x = -this.x;
                y = -this.y;
                z = -this.z;
                return this;
            }

            // Cuaternion q = Cuaternion a . Cuaternion b
            multiplica(a, b) {
                let q = new Cuaternion(0, 0, 0, 0);
                q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
                q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
                q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
                q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
                return q;
            }

            // Cuaternion q = Cuaternion a . b
            multiplica_escalar(a, b) {
                let q = new Cuaternion(0, 0, 0, 0);
                q.w = a.w * b;
                q.x = a.x * b;
                q.y = a.y * b;
                q.z = a.z * b;
                return q;
            }

            // q' = q . p . q^(-1)
            rota(q, p) {   // q es Cuaternion y p es Vector3
                let p_homogeneo = new Cuaternion(0, 0, 0, 0);
                p_homogeneo.inicializa(0, p);
                let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.inverso()));
                return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
            }

            // q' = q . p . q*
            rota1(q, p) {  // q es Cuaternion y p es Vector3
                let p_homogeneo = new Cuaternion(0, 0, 0, 0);
                p_homogeneo.inicializa(0, p);
                let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.conjugado()));
                return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
            }

            // q = q^(-1)
            inverso() {
                let q = new Cuaternion(0, 0, 0, 0);
                // normal^2 = a . b
                let n = this.norma2();
                if (n <= 1e-8)
                    document.write("INVERSO: Error");
                q = multiplica_escalar(new Cuaternion(this.w, -this.x, -this.y, -this.z), 1 / n);
                return q;
            }

            /* Convierte el cuaternión a una matriz de rotación */
            static rota2(a, q) {
                let d, s;
                d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w);
                s = (d > 0.0) ? (2.0 / d) : 0.0;
                a[0] = 1.0 - (q.y * q.y + q.z * q.z) * s; a[4] = (q.x * q.y - q.w * q.z) * s; a[8] = (q.x * q.z + q.w * q.y) * s; a[12] = 0;
                a[1] = (q.x * q.y + q.w * q.z) * s; a[5] = 1.0 - (q.x * q.x + q.z * q.z) * s; a[9] = (q.y * q.z - q.w * q.x) * s; a[13] = 0;
                a[2] = (q.x * q.z - q.w * q.y) * s; a[6] = (q.y * q.z + q.w * q.x) * s; a[10] = 1.0 - (q.x * q.x + q.y * q.y) * s; a[14] = 0;
                a[3] = 0; a[7] = 0; a[11] = 0; a[15] = 1;
            }

            toString() {
                return "Cuaternion [w=" + this.w + ", x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
            }
        }

        function mouseDown(event) {
            let posx = event.clientX - canvas.offsetLeft;
            let posy = event.clientY - canvas.offsetTop;

            let rect = canvas.getBoundingClientRect();
            let xN = (posx / rect.width) * 2 - 1;
            let yN = 1 - (posy / rect.height) * 2;

            //Determina qué objeto está más cerca del cursor
            //Recorre todos los modelos (modelos[]) y calcula la distancia cuadrada entre el mouse y cada objeto:

            //dist=(x_mouse​−x_obj​/zoom)2+(y_mouse​−y_obj​/zoom)2

            let minDist = Infinity;
            for (let i = 0; i < modelos.length; i++) {
                let dx = xN - modelos[i].posicion.x / zoom;
                let dy = yN - modelos[i].posicion.y / zoom;
                let dist = dx * dx + dy * dy;
                if (dist < minDist) {
                    minDist = dist;
                    modeloActivo = i;
                }
            }

            let nombres = ["Cráneo", "Tronco", "Omóplato", "Corazón", "Extremidades Superiores", "Pelvis", "Extremidades Inferiores"];
            document.getElementById("infoModelo").innerText = "Modelo seleccionado: " + nombres[modeloActivo];

            //Guardar rotación previa del objeto
            modelos[modeloActivo].B = modelos[modeloActivo].MatrizRotacion.slice();

            // Preparar ArcBall
            arcBall.primerPunto(posx, posy);

            // Preparar para mover
            //arrastrando = true → indica que el mouse está presionado y se puede mover/rotar
            arrastrando = true;

            offsetX = modelos[modeloActivo].posicion.x - xN * zoom;
            offsetY = modelos[modeloActivo].posicion.y - yN * zoom;

            boton_izq_presionado = true;

            return false;
        };


        function mouseUp(e) {
            boton_izq_presionado = false;
        };

        function mouseMove(event) {
            if (!boton_izq_presionado) return false;

            let posx = event.clientX - canvas.offsetLeft;
            let posy = event.clientY - canvas.offsetTop;

            let rect = canvas.getBoundingClientRect();
            let xN = (posx / rect.width) * 2 - 1;
            let yN = 1 - (posy / rect.height) * 2;

            if (modoMover) {
                modelos[modeloActivo].posicion.x = xN * zoom + offsetX;
                modelos[modeloActivo].posicion.y = yN * zoom + offsetY;
                return;
            }

            let q = arcBall.segundoPunto(posx, posy);
            Cuaternion.rota2(modelos[modeloActivo].MatrizRotacion, q);
            multiplica(modelos[modeloActivo].MatrizRotacion, modelos[modeloActivo].MatrizRotacion, modelos[modeloActivo].B);
        }


        class Cubo {
            constructor(gl, rutaArchivo, rutaImagen) {
                this.gl = gl;
                this.modelo = null;
                this.modeloVAO = null;
                this.textura = null; // nuevo

                this.MatrizRotacion = new Array(16);
                identidad(this.MatrizRotacion);

                this.MatrizModelo = new Array(16);
                identidad(this.MatrizModelo);

                this.posicion = new Vector3(0, 0, 0);

this.escala = new Vector3(7, 7, 7);

                fetch(rutaArchivo)
                    .then(resp => resp.text())
                    .then(texto => {
                        this.modelo = new OBJ.Mesh(texto);

                        // Centrar modelo
                        let minX = Infinity, minY = Infinity, minZ = Infinity;
                        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                        for (let i = 0; i < this.modelo.vertices.length; i += 3) {
                            let x = this.modelo.vertices[i];
                            let y = this.modelo.vertices[i + 1];
                            let z = this.modelo.vertices[i + 2];
                            if (x < minX) minX = x; if (x > maxX) maxX = x;
                            if (y < minY) minY = y; if (y > maxY) maxY = y;
                            if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
                        }

                        let cx = (minX + maxX) / 2.0;
                        let cy = (minY + maxY) / 2.0;
                        let cz = (minZ + maxZ) / 2.0;

                        for (let i = 0; i < this.modelo.vertices.length; i += 3) {
                            this.modelo.vertices[i] -= cx;
                            this.modelo.vertices[i + 1] -= cy;
                            this.modelo.vertices[i + 2] -= cz;
                        }

                        this.modeloVAO = gl.createVertexArray();
                        gl.bindVertexArray(this.modeloVAO);

                        // VBO vertices
                        let vbo = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.modelo.vertices), gl.STATIC_DRAW);
                        gl.enableVertexAttribArray(0);
                        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                        // VBO UV (si hay)
                        if (this.modelo.textures && this.modelo.textures.length > 0) {
                            let vboUV = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, vboUV);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.modelo.textures), gl.STATIC_DRAW);
                            gl.enableVertexAttribArray(1);
                            gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
                        }

                        // indices
                        let ebo = gl.createBuffer();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(this.modelo.indices), gl.STATIC_DRAW);

                        gl.bindVertexArray(null);
                        gl.bindBuffer(gl.ARRAY_BUFFER, null);

                        // cargar textura si se pasó ruta
                        if (rutaImagen) this.cargarTextura(rutaImagen);
                    });
            }

            cargarTextura(rutaImagen) {
                let gl = this.gl;
                let img = new Image();
                img.src = rutaImagen;
                img.onload = () => {
                    this.textura = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.textura);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                };
            }

            dibuja(shaderProgram) {
                if (!this.modeloVAO) return;
                let gl = this.gl;
                gl.bindVertexArray(this.modeloVAO);

                if (this.textura) {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this.textura);
                    let loc = gl.getUniformLocation(shaderProgram, "uUnidadDeTextura");
                    gl.uniform1i(loc, 0);
                }

                if (modoMalla) {
                    gl.drawElements(gl.TRIANGLES, this.modelo.indices.length, gl.UNSIGNED_INT, 0);
                } else {
                    gl.drawElements(gl.LINES, this.modelo.indices.length, gl.UNSIGNED_INT, 0);
                }

                gl.bindVertexArray(null);
            }


            actualizarColor(nuevoColor) {
                // se mantiene igual
                this.colorActual = nuevoColor;

                let colores = [];
                let numVertices = this.modelo.vertices.length / 3;
                for (let i = 0; i < numVertices; i++) {
                    colores.push(nuevoColor[0], nuevoColor[1], nuevoColor[2], nuevoColor[3]);
                }

                let gl = this.gl;
                gl.bindVertexArray(this.modeloVAO);
                let cbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
                gl.bindVertexArray(null);
            }
        }


        function dibuja() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            for (let i = 0; i < modelos.length; i++) {
                identidad(modelos[i].MatrizModelo);
                traslacion(modelos[i].MatrizModelo, modelos[i].posicion.x, modelos[i].posicion.y, modelos[i].posicion.z);
                rotacionY(modelos[i].MatrizModelo, 90);
                multiplica(modelos[i].MatrizModelo, modelos[i].MatrizModelo, modelos[i].MatrizRotacion);

                escalacion(modelos[i].MatrizModelo,
           modelos[i].escala.x,
           modelos[i].escala.y,
           modelos[i].escala.z);

                gl.uniformMatrix4fv(uMatrizModelo, false, modelos[i].MatrizModelo);
                modelos[i].dibuja(programaID);
            }
            requestAnimationFrame(dibuja);
        }



        function actualizarZoom() {
            let aspecto = gl.canvas.width / gl.canvas.height;
            ortho(
                MatrizProyeccion,
                -zoom * aspecto,
                zoom * aspecto,
                -zoom,
                zoom,
                -zoom,
                zoom
            );
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
        }


        function main() {
            canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");
            if (!gl) { alert("WebGL2 no disponible"); return; }

            // Eventos de ratón
            canvas.addEventListener("mousedown", mouseDown, false);
            canvas.addEventListener("mouseup", mouseUp, false);
            canvas.addEventListener("mouseout", mouseUp, false);
            canvas.addEventListener("mousemove", mouseMove, false);

            gl.viewport(0, 0, canvas.width, canvas.height);
            let vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, document.getElementById("vs").text.trim());
            gl.compileShader(vs);
            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                console.error("Error VS:", gl.getShaderInfoLog(vs));
            }
            let fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, document.getElementById("fs").text.trim());
            gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                console.error("Error FS:", gl.getShaderInfoLog(fs));
            }

            programaID = gl.createProgram();
            gl.attachShader(programaID, vs);
            gl.attachShader(programaID, fs);
            gl.linkProgram(programaID);
            if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
                console.error("Error Programa:", gl.getProgramInfoLog(programaID));
            }

            arcBall = new ArcBall(500.0, 500.0);
            gl.useProgram(programaID);

            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");


            let corazon = new Cubo(gl, "corazon.obj", "pcorazon/texturacorazon2.png");
            corazon.posicion = new Vector3(5, 4, 0);
            modelos.push(corazon);

            let cerebro = new Cubo(gl, "cerebro.obj", "pcorazon/texturacerebro.png");
            cerebro.posicion = new Vector3(5, 2, 0);
            cerebro.escala = new Vector3(2,2,2);

            modelos.push(cerebro);

            let craneo = new Cubo(gl, "craneo.obj", "texturahueso1.jpg");
            craneo.posicion = new Vector3(-5, 6, 0);
            modelos.push(craneo);

            let omoplato = new Cubo(gl, "omoplato.obj", "texturahueso1.jpg");
            omoplato.posicion = new Vector3(-5, 4, 0);
            modelos.push(omoplato);


            let tronco = new Cubo(gl, "tronco2.obj", "texturahueso1.jpg");
            tronco.posicion = new Vector3(-5, 3.5, 0);
            modelos.push(tronco);

            

            let extremidadesSup = new Cubo(gl, "extremidadesSup.obj", "texturahueso1.jpg");
            extremidadesSup.posicion = new Vector3(-5, 1, 0);
            modelos.push(extremidadesSup);


            let pelvis = new Cubo(gl, "pelvis.obj", "texturahueso1.jpg");
            pelvis.posicion = new Vector3(-5,0, 0);
            modelos.push(pelvis);

             let extremidadesI = new Cubo(gl, "extremidadesI.obj", "texturahueso1.jpg");
            extremidadesI.posicion = new Vector3(-5, -4, 0);
            modelos.push(extremidadesI);


            ortho(MatrizProyeccion, -10, 10, -10, 10, -10, 10);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

            identidad(MatrizRotacion);
            arcBall.ajusta(gl.canvas.width, gl.canvas.height);

            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(0, 1, 0, 1);

            dibuja();
        }



        document.getElementById("reset").onclick = () => {


        };

        document.getElementById("zoomMas").onclick = () => {
            zoom -= 0.3;
            if (zoom < 1) zoom = 1;
            actualizarZoom();
        };

        document.getElementById("zoomMenos").onclick = () => {
            zoom += 0.3;
            actualizarZoom();
        };

        document.getElementById("malla").onclick = () => {
            modoMalla = !modoMalla;
        };

        document.getElementById("mover").onclick = () => {
            modoMover = !modoMover;
            if (modoMover) {
                document.getElementById("mover").style.background = "#888"; // resalta si activo
            } else {
                document.getElementById("mover").style.background = "#555"; // normal si inactivo
            }
        };
        document.getElementById("seleccionModelo").onchange = (e) => {
            let valor = e.target.value;

            switch (valor) {
                case "craneo":
                    modelos[0].actualizarColor([104 / 255, 112 / 255, 16 / 255, 1]);
                    break;
                case "tronco":
                    modelos[1].actualizarColor([0, 1, 0, 1]); // verde
                    break;
                case "omoplato":
                    modelos[2].actualizarColor([0, 0, 1, 1]);
                    break;
                case "pelvis":
                    modelos[3].actualizarColor([0, 183 / 255, 183 / 255, 1]);
                    break;
                case "extremidadesI":
                    modelos[4].actualizarColor([239 / 255, 128 / 255, 80 / 255, 1]);
                    break;
                case "extremidadesSup":
                    modelos[5].actualizarColor([167 / 255, 65 / 255, 157 / 255, 1]);
                    break;
                case "clavicula":
                    modelos[6].actualizarColor([106 / 255, 234 / 255, 21 / 255, 1]);
                    break;
            }
        };


        window.onload = main;
    </script>
</body>

</html>